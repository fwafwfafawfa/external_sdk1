#include "exploits.hpp"
#include <thread>
#include <chrono>
#include "../../../main.hpp"
#include "../../../game/core.hpp"
#include "../../../handlers/vars.hpp"
#include "../../../addons/kernel/memory.hpp"
#include "../../../handlers/utility/utility.hpp"

using namespace vars;

namespace exploits {

void allow_friendly_fire() {
    std::thread([](){
        while (true) {
            if (!vars::exploits::enabled || !vars::exploits::friendly_fire) {
                std::this_thread::sleep_for(std::chrono::milliseconds(85));
                continue;
            }

            // Attempt to find local player character model
            if (!g_main::datamodel || !g_main::localplayer) {
                std::this_thread::sleep_for(std::chrono::milliseconds(85));
                util.m_print("allow_friendly_fire: localplayer/datamodel missing");
                continue;
            }

            // Find Players container and local player instance
            uintptr_t players_instance = core.find_first_child_class(g_main::datamodel, "Players");
            if (!players_instance) {
                std::this_thread::sleep_for(std::chrono::milliseconds(85));
                util.m_print("allow_friendly_fire: Players instance not found");
                continue;
            }

            uintptr_t local_player = memory->read<uintptr_t>(players_instance + offsets::LocalPlayer);
            if (!local_player) {
                std::this_thread::sleep_for(std::chrono::milliseconds(85));
                util.m_print("allow_friendly_fire: localplayer pointer invalid");
                continue;
            }

            // Try to find a FriendlyFire boolean in the player's instance memory
            auto children = core.children(local_player);
            bool set_success = false;
            for (auto child : children) {
                std::string name = core.get_instance_name(child);
                if (name == "FriendlyFire") {
                    // If this child has a boolean property at offsets::Value or similar, try to set
                    // Many instances use Value as a property pointer; try writing bool directly to that offset
                    uintptr_t value_addr = child + offsets::Value;
                    // Attempt to write a byte (bool) there
                    memory->write<uint8_t>(value_addr, 1);
                    // Verify
                    uint8_t val = memory->read<uint8_t>(value_addr);
                    if (val == 1) {
                        set_success = true;
                        break;
                    }
                }
            }

            if (!set_success) {
                // Fallback: try to search attributes under player for a 'FriendlyFire' attribute
                util.m_print("allow_friendly_fire: FriendlyFire child not found or couldn't set");
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(30));
        }
    }).detach();
}

} // namespace exploits
